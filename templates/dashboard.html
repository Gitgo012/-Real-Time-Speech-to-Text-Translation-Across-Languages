<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Real-time Speech Translation - Dashboard</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='dashboard.css') }}" />
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
  </head>
  <body>
    <!-- Header -->
    <header>
      <div class="header-content">
        <div class="app-title">
          <h1>üé§ Real-Time Speech Translation</h1>
          <span class="subtitle">Powered by Faster-Whisper & Hugging Face</span>
        </div>
        <div class="user-info">
          <span class="welcome-text">
            Welcome, <strong>{{ username }}</strong>!
          </span>
          <a href="{{ url_for('logout') }}" class="logout-btn">Logout</a>
        </div>
      </div>
    </header>

    <!-- Main Content -->
    <main>
      <!-- Main Panel: Controls (Left) + Results (Right) -->
      <div class="main-panel">
        <!-- Control Panel (Left Side) -->
        <section class="control-panel">
          <div class="control-section">
            <h2>Language Selection</h2>
            <div class="language-selector">
              <label for="languageSelect">Target Translation Language</label>
              <select id="languageSelect">
                <option value="">Select target language</option>
              </select>
            </div>
          </div>

          <div class="control-section">
            <h2>Recording Controls</h2>
            <div class="recording-controls">
              <button id="startBtn" onclick="startRecording()">
                <span>‚ñ∂</span> Start Recording
              </button>
              <button id="stopBtn" onclick="stopRecording()" disabled>
                <span>‚èπ</span> Stop Recording
              </button>
            </div>
          </div>

          <div class="control-section">
            <h2>Status</h2>
            <div class="status-indicator">
              <div id="status">Ready to start</div>
            </div>
          </div>
        </section>

        <!-- Results Panel (Right Side) -->
        <section class="results-panel">
          <div class="result-section">
            <h3>Original Text (Transcribed)</h3>
            <div class="result-box" id="originalText" role="textbox" aria-label="Original transcribed text">-</div>
          </div>

          <div class="result-section">
            <h3>Translated Text</h3>
            <div class="result-box" id="translatedText" role="textbox" aria-label="Translated text">-</div>
          </div>
        </section>
      </div>
    </main>

    <!-- Footer -->
    <footer>
      <div class="footer-content">
        <p>
          <strong>Real-Time Speech-to-Text Translation Across Languages</strong>
        </p>
        <p>
          Built with <a href="https://github.com/guillaumekln/faster-whisper" target="_blank">Faster-Whisper</a> 
          and <a href="https://huggingface.co/models" target="_blank">Hugging Face Transformers</a>
        </p>
        <div class="contributors">
          Contributors: Arpit Deewan, Harsha Vardhan Babu, Shikhar Sharma, Vartika Singh, Yash Kuletha
        </div>
      </div>
    </footer>

    <!-- JavaScript -->
    <script>
      // ============================================
      // WebSocket and Audio Recording Logic
      // ============================================
      
      let mediaRecorder;
      let audioContext;
      let isRecording = false;
      let socket;
      let stream;

      // Initialize on page load
      document.addEventListener("DOMContentLoaded", function () {
        socket = io();

        socket.on("connect", function () {
          updateStatus("Connected to server");
        });

        socket.on("disconnect", function () {
          updateStatus("Disconnected from server");
        });

        socket.on("available_languages", function (data) {
          const select = document.getElementById("languageSelect");
          select.innerHTML = '<option value="">Select target language</option>';

          for (const [label, code] of Object.entries(data.languages)) {
            const option = document.createElement("option");
            option.value = code;
            option.textContent = label;
            select.appendChild(option);
          }

          if (!data.asr_ready) {
            updateStatus("ASR model not ready. Please wait...");
            document.getElementById("startBtn").disabled = true;
          } else {
            updateStatus("Ready to start");
          }
        });

        socket.on("transcription_result", function (data) {
          const originalEl = document.getElementById("originalText");
          const translatedEl = document.getElementById("translatedText");
          
          originalEl.textContent = data.original;
          translatedEl.textContent = data.translated || "No translation available";
          
          // Add animation class for visual feedback
          originalEl.classList.add("updated");
          translatedEl.classList.add("updated");
          setTimeout(() => {
            originalEl.classList.remove("updated");
            translatedEl.classList.remove("updated");
          }, 300);

          if (data.success) {
            updateStatus("Processing complete");
          } else {
            updateStatus("Processing failed: " + data.original);
          }
        });

        socket.on("error", function (data) {
          updateStatus("Error: " + data.message);
        });
      });

      // Update status message
      function updateStatus(message) {
        const statusEl = document.getElementById("status");
        statusEl.textContent = message;
      }

      // Start recording audio
      async function startRecording() {
        const targetLang = document.getElementById("languageSelect").value;
        if (!targetLang) {
          alert("Please select a target language first");
          return;
        }

        try {
          stream = await navigator.mediaDevices.getUserMedia({
            audio: {
              channelCount: 1,
              sampleRate: 16000,
              echoCancellation: true,
              noiseSuppression: true,
            },
          });

          audioContext = new AudioContext({ sampleRate: 16000 });
          const source = audioContext.createMediaStreamSource(stream);
          const gainNode = audioContext.createGain();
          gainNode.gain.value = 0;
          source.connect(gainNode);

          const options = {
            mimeType: "audio/webm;codecs=opus",
            audioBitsPerSecond: 16000,
          };
          if (!MediaRecorder.isTypeSupported(options.mimeType)) {
            console.warn(
              "WebM with Opus not supported, falling back to default"
            );
            delete options.mimeType;
          }

          mediaRecorder = new MediaRecorder(stream, options);
          let chunks = [];

          mediaRecorder.ondataavailable = function (event) {
            if (event.data.size > 0) chunks.push(event.data);
          };

          mediaRecorder.onstop = function () {
            const blob = new Blob(chunks, { type: "audio/webm" });
            chunks = [];

            const reader = new FileReader();
            reader.onload = function () {
              if (socket && socket.connected) {
                socket.emit("audio_chunk", {
                  audio: reader.result,
                  target_lang: targetLang,
                });
              }
            };
            reader.readAsDataURL(blob);
          };

          mediaRecorder.start(1000);
          isRecording = true;
          document.getElementById("startBtn").disabled = true;
          document.getElementById("stopBtn").disabled = false;
          updateStatus("Recording...");
        } catch (error) {
          console.error("Error starting recording:", error);
          updateStatus("Error: " + error.message);
        }
      }

      // Stop recording audio
      function stopRecording() {
        if (mediaRecorder && isRecording) {
          mediaRecorder.stop();
          isRecording = false;
          if (audioContext) audioContext.close();
          if (stream) stream.getTracks().forEach((track) => track.stop());

          document.getElementById("startBtn").disabled = false;
          document.getElementById("stopBtn").disabled = true;
          updateStatus("Recording stopped");
        }
      }
    </script>
  </body>
</html>
